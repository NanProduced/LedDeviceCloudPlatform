# 节目编辑器后端服务架构设计

## 1. 微服务架构设计

### 1.1 服务模块划分
```
┌─────────────────────────────────────────────────────────────┐
│                     API Gateway                            │
│            (路由、认证、限流、日志)                          │  
└─────────────────────────────────────────────────────────────┘
                                ↓
┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐
│   节目管理服务   │ │   VSN生成服务   │ │  预览渲染服务   │
│ Program Service │ │  VSN Generator  │ │Preview Service  │
└─────────────────┘ └─────────────────┘ └─────────────────┘
         ↓                      ↓                      ↓
┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐
│   素材管理服务   │ │   文件存储服务   │ │   消息通知服务   │
│Material Service │ │  File Service   │ │Message Service  │
└─────────────────┘ └─────────────────┘ └─────────────────┘
```

### 1.2 核心服务职责定义

#### A. 节目管理服务 (Program Service)
**职责范围：**
- 节目CRUD操作和生命周期管理
- 节目版本控制和历史记录
- 节目权限和共享管理
- 节目模板和分类管理

**领域模型扩展：**
```java
// 扩展现有Program领域模型
@Entity
@Table(name = "material_program")
public class Program {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long programId;
    
    private String programName;
    private String description;
    
    // 节目规格信息
    private Integer canvasWidth;
    private Integer canvasHeight;
    private String deviceType; // LED屏型号兼容性
    
    // 组织和权限
    private Long organizationId;
    private Long userGroupId; // 所属用户组
    private Long creatorId;
    private Long updaterId;
    
    // 状态管理
    @Enumerated(EnumType.STRING)
    private ProgramStatus status; // DRAFT, PUBLISHED, ARCHIVED
    
    // MongoDB文档引用
    private String programContentId; // 节目详细内容的MongoDB ObjectId
    private String vsnFileId; // 生成的VSN文件ID
    
    // 版本管理
    private Integer version;
    private Long parentProgramId; // 复制来源
    
    // 使用统计
    private Integer deployCount; // 部署次数
    private LocalDateTime lastDeployTime;
    
    // 审核和发布
    @Enumerated(EnumType.STRING)
    private ApprovalStatus approvalStatus; // PENDING, APPROVED, REJECTED
    private Long approverId;
    private String approvalComment;
    
    // 缩略图和预览
    private String thumbnailPath;
    private String previewVideoPath;
    
    // 时间戳
    private LocalDateTime createTime;
    private LocalDateTime updateTime;
    
    // 标签和分类
    @ElementCollection
    private Set<String> tags;
    private String category;
    
    // 兼容性信息
    @ElementCollection
    private Set<String> supportedDeviceTypes;
    private String minPlayerVersion;
}

enum ProgramStatus {
    DRAFT("草稿"),
    PUBLISHED("已发布"), 
    ARCHIVED("已归档"),
    TEMPLATE("模板");
}

enum ApprovalStatus {
    PENDING("待审核"),
    APPROVED("已通过"),
    REJECTED("已拒绝");
}
```

**MongoDB文档结构设计：**
```java
// 节目详细内容的MongoDB文档结构
@Document(collection = "program_content")
public class ProgramContent {
    @Id
    private String id;
    
    private String programId; // 关联MySQL中的program_id
    
    // 节目基础信息（与VSN Information对应）
    private ProgramInformation information;
    
    // 节目页面列表（与VSN Pages对应）
    private List<ProgramPage> pages;
    
    // 编辑器状态数据
    private EditorState editorState;
    
    // 素材引用关系
    private Set<MaterialReference> materialReferences;
    
    // 版本和时间戳
    private Integer contentVersion;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
    
    // 编辑历史
    private List<EditAction> editHistory;
}

@Data
public class ProgramInformation {
    private Integer width;
    private Integer height;
    private String backgroundColor;
    private String deviceProfile; // 设备配置文件
}

@Data  
public class ProgramPage {
    private String id;
    private String name;
    private Integer duration; // appointDuration
    private Integer loopType; // 0=指定时长，1=自动计算
    private String bgColor;
    private BgFile bgFile;
    private List<BgAudio> bgAudios;
    private List<ProgramRegion> regions;
    private Integer sortOrder;
}

@Data
public class ProgramRegion {
    private String id;
    private String name;
    private DisplayRect rect;
    private List<ProgramItem> items;
    private Integer layer;
    private Boolean isScheduleRegion;
    private String regionType; // sync_program, singleline_scroll等
}

@Data
public class ProgramItem {
    private String id;
    private String itemType; // 对应VSN type: 2,3,4,5,6,9,14等
    private MaterialReference materialRef; // 引用的素材信息
    private ItemProperties properties; // 各种Item属性
    private ItemSchedule schedule; // 排程信息
    private Integer sortOrder;
}

@Data
public class MaterialReference {
    private String materialId;
    private String fileId;
    private String materialType;
    private String md5Hash;
    private String storagePath;
    private String accessUrl;
    private Long fileSize;
    private String mimeType;
}

@Data
public class ItemProperties {
    // 通用属性
    private String backColor;
    private Effect inEffect;
    private String name;
    
    // 图片/视频属性
    private String alpha;
    private String reserveAS;
    private String duration;
    
    // 文本属性
    private String text;
    private String textColor;
    private LogFont logFont;
    private String isScroll;
    private String scrollSpeed;
    private String centerAlign;
    
    // 时钟属性
    private String timezone;
    private String isAnalog;
    private DigitalClock digitalClock;
    
    // 其他专用属性...
    private Map<String, Object> customProperties;
}
```

#### B. VSN生成服务 (VSN Generator Service)
**职责范围：**
- 节目编辑数据到VSN XML的转换
- FileSource路径解析和文件引用管理
- VSN文件验证和兼容性检查
- 节目文件打包和部署准备

**核心服务接口：**
```java
@Service
public class VsnGeneratorService {
    
    /**
     * 生成VSN XML文件
     */
    public VsnGenerationResult generateVsnXml(String programId, VsnGenerationOptions options) {
        // 1. 获取节目内容数据
        ProgramContent content = programContentRepository.findByProgramId(programId);
        Program program = programRepository.findById(Long.valueOf(programId));
        
        // 2. 构建VSN文档结构
        VsnDocument vsnDoc = buildVsnDocument(content, program);
        
        // 3. 解析和转换素材引用
        processFileSourceReferences(vsnDoc, options);
        
        // 4. 生成XML文件
        String xmlContent = convertToXml(vsnDoc);
        
        // 5. 验证VSN格式
        VsnValidationResult validation = validateVsn(xmlContent);
        
        // 6. 保存VSN文件
        String vsnFileId = saveVsnFile(programId, xmlContent);
        
        return VsnGenerationResult.builder()
                .vsnFileId(vsnFileId)
                .xmlContent(xmlContent)
                .validation(validation)
                .materialFiles(vsnDoc.getReferencedFiles())
                .build();
    }
    
    /**
     * 处理FileSource引用
     */
    private void processFileSourceReferences(VsnDocument vsnDoc, VsnGenerationOptions options) {
        for (FileSourceReference ref : vsnDoc.getFileReferences()) {
            Material material = materialService.getMaterialById(ref.getMaterialId());
            
            // 根据部署模式决定路径策略
            FileSource fileSource = switch (options.getDeploymentMode()) {
                case LOCAL -> buildLocalFileSource(material, options);
                case CLOUD -> buildCloudFileSource(material, options);
                case HYBRID -> buildHybridFileSource(material, options);
            };
            
            ref.setFileSource(fileSource);
        }
    }
    
    private FileSource buildLocalFileSource(Material material, VsnGenerationOptions options) {
        return FileSource.builder()
                .isRelative("1") // 使用相对路径
                .filePath(generateRelativePath(material, options.getLocalBasePath()))
                .md5(material.getMd5Hash())
                .originName(material.getMaterialName())
                .build();
    }
    
    private FileSource buildCloudFileSource(Material material, VsnGenerationOptions options) {
        return FileSource.builder()
                .isRelative("0") // 使用绝对路径
                .filePath(storageService.generateAccessUrl(material.getStoragePath()))
                .md5(material.getMd5Hash())
                .originName(material.getMaterialName())
                .build();
    }
}

@Data
@Builder
public class VsnGenerationOptions {
    private DeploymentMode deploymentMode; // LOCAL, CLOUD, HYBRID
    private String localBasePath; // 本地部署的基础路径
    private String deviceType; // 目标设备类型
    private String playerVersion; // 播放器版本
    private Boolean includePreview; // 是否包含预览文件
    private Boolean validateCompatibility; // 是否验证兼容性
    private Map<String, String> customProperties; // 自定义属性
}

enum DeploymentMode {
    LOCAL("本地部署"),
    CLOUD("云端部署"), 
    HYBRID("混合部署");
}
```

**VSN XML生成器实现：**
```java
@Component
public class VsnXmlBuilder {
    
    public String buildVsnXml(VsnDocument vsnDoc) {
        XMLOutputFactory factory = XMLOutputFactory.newInstance();
        StringWriter writer = new StringWriter();
        
        try {
            XMLStreamWriter xmlWriter = factory.createXMLStreamWriter(writer);
            
            // XML声明
            xmlWriter.writeStartDocument("UTF-8", "1.0");
            
            // 根元素 <Programs>
            xmlWriter.writeStartElement("Programs");
            
            // 节目元素 <Program>
            xmlWriter.writeStartElement("Program");
            
            // Information部分
            writeInformation(xmlWriter, vsnDoc.getInformation());
            
            // Pages部分
            writePages(xmlWriter, vsnDoc.getPages());
            
            xmlWriter.writeEndElement(); // </Program>
            xmlWriter.writeEndElement(); // </Programs>
            xmlWriter.writeEndDocument();
            
            xmlWriter.flush();
            xmlWriter.close();
            
        } catch (XMLStreamException e) {
            throw new VsnGenerationException("VSN XML生成失败", e);
        }
        
        return writer.toString();
    }
    
    private void writeInformation(XMLStreamWriter writer, ProgramInformation info) throws XMLStreamException {
        writer.writeStartElement("Information");
        writer.writeStartElement("Height");
        writer.writeCharacters(info.getHeight().toString());
        writer.writeEndElement();
        writer.writeStartElement("Width");
        writer.writeCharacters(info.getWidth().toString());
        writer.writeEndElement();
        writer.writeEndElement();
    }
    
    private void writePages(XMLStreamWriter writer, List<VsnPage> pages) throws XMLStreamException {
        writer.writeStartElement("Pages");
        
        for (VsnPage page : pages) {
            writePage(writer, page);
        }
        
        writer.writeEndElement();
    }
    
    private void writePage(XMLStreamWriter writer, VsnPage page) throws XMLStreamException {
        writer.writeStartElement("Page");
        
        // AppointDuration
        writer.writeStartElement("AppointDuration");
        writer.writeCharacters(page.getDuration().toString());
        writer.writeEndElement();
        
        // LoopType
        writer.writeStartElement("LoopType");
        writer.writeCharacters(page.getLoopType().toString());
        writer.writeEndElement();
        
        // Regions
        writeRegions(writer, page.getRegions());
        
        writer.writeEndElement();
    }
    
    private void writeRegions(XMLStreamWriter writer, List<VsnRegion> regions) throws XMLStreamException {
        writer.writeStartElement("Regions");
        
        for (VsnRegion region : regions) {
            writeRegion(writer, region);
        }
        
        writer.writeEndElement();
    }
    
    private void writeRegion(XMLStreamWriter writer, VsnRegion region) throws XMLStreamException {
        writer.writeStartElement("Region");
        
        // Rect
        writeRect(writer, region.getRect());
        
        // Items
        writeItems(writer, region.getItems());
        
        writer.writeEndElement();
    }
    
    private void writeItems(XMLStreamWriter writer, List<VsnItem> items) throws XMLStreamException {
        writer.writeStartElement("Items");
        
        for (VsnItem item : items) {
            writeItem(writer, item);
        }
        
        writer.writeEndElement();
    }
    
    private void writeItem(XMLStreamWriter writer, VsnItem item) throws XMLStreamException {
        writer.writeStartElement("Item");
        
        // Type (必填)
        writer.writeStartElement("Type");
        writer.writeCharacters(item.getType());
        writer.writeEndElement();
        
        // 根据类型写入专用属性
        switch (item.getType()) {
            case "2": // 图片
                writeImageProperties(writer, item);
                break;
            case "3": // 视频
                writeVideoProperties(writer, item);
                break;
            case "4", "5": // 文本
                writeTextProperties(writer, item);
                break;
            case "6": // GIF
                writeGifProperties(writer, item);
                break;
            case "9": // 时钟
                writeClockProperties(writer, item);
                break;
            // ... 其他类型
        }
        
        writer.writeEndElement();
    }
    
    private void writeImageProperties(XMLStreamWriter writer, VsnItem item) throws XMLStreamException {
        ItemProperties props = item.getProperties();
        
        // FileSource (必填)
        writeFileSource(writer, item.getFileSource());
        
        // Alpha (必填)
        writer.writeStartElement("alhpa"); // 注意：VSN格式中确实是alhpa不是alpha
        writer.writeCharacters(props.getAlpha() != null ? props.getAlpha() : "1.0");
        writer.writeEndElement();
        
        // Duration (可选)
        if (props.getDuration() != null) {
            writer.writeStartElement("duration");
            writer.writeCharacters(props.getDuration());
            writer.writeEndElement();
        }
        
        // ReserveAS (可选)
        if (props.getReserveAS() != null) {
            writer.writeStartElement("reserveAS");
            writer.writeCharacters(props.getReserveAS());
            writer.writeEndElement();
        }
        
        // InEffect (可选)
        if (props.getInEffect() != null) {
            writeEffect(writer, props.getInEffect());
        }
    }
    
    private void writeFileSource(XMLStreamWriter writer, FileSource fileSource) throws XMLStreamException {
        writer.writeStartElement("filesource");
        
        writer.writeStartElement("isrelative");
        writer.writeCharacters(fileSource.getIsRelative());
        writer.writeEndElement();
        
        writer.writeStartElement("filepath");
        writer.writeCharacters(fileSource.getFilePath());
        writer.writeEndElement();
        
        if (fileSource.getMd5() != null) {
            writer.writeStartElement("MD5");
            writer.writeCharacters(fileSource.getMd5());
            writer.writeEndElement();
        }
        
        if (fileSource.getOriginName() != null) {
            writer.writeStartElement("originName");
            writer.writeCharacters(fileSource.getOriginName());
            writer.writeEndElement();
        }
        
        writer.writeEndElement();
    }
}
```

#### C. 预览渲染服务 (Preview Service)
**职责范围：**
- 节目预览图生成
- 节目预览视频渲染
- 实时预览数据推送
- 设备兼容性预览

```java
@Service
public class ProgramPreviewService {
    
    /**
     * 生成节目预览图
     */
    public PreviewGenerationResult generatePreview(String programId, PreviewOptions options) {
        // 1. 获取节目内容
        ProgramContent content = programContentRepository.findByProgramId(programId);
        
        // 2. 渲染预览图
        BufferedImage previewImage = renderProgramPreview(content, options);
        
        // 3. 保存预览图
        String previewPath = savePreviewImage(programId, previewImage);
        
        // 4. 生成缩略图
        String thumbnailPath = generateThumbnail(previewImage, programId);
        
        return PreviewGenerationResult.builder()
                .previewPath(previewPath)
                .thumbnailPath(thumbnailPath)
                .width(previewImage.getWidth())
                .height(previewImage.getHeight())
                .build();
    }
    
    /**
     * 渲染程序预览
     */
    private BufferedImage renderProgramPreview(ProgramContent content, PreviewOptions options) {
        // 创建画布
        BufferedImage canvas = new BufferedImage(
            content.getInformation().getWidth(),
            content.getInformation().getHeight(),
            BufferedImage.TYPE_INT_ARGB
        );
        
        Graphics2D g2d = canvas.createGraphics();
        
        // 设置渲染质量
        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        g2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
        
        // 绘制背景
        g2d.setColor(Color.BLACK);
        g2d.fillRect(0, 0, canvas.getWidth(), canvas.getHeight());
        
        // 渲染第一页（或指定页面）
        ProgramPage page = content.getPages().get(options.getPageIndex());
        renderPage(g2d, page, options);
        
        g2d.dispose();
        return canvas;
    }
    
    private void renderPage(Graphics2D g2d, ProgramPage page, PreviewOptions options) {
        // 渲染页面背景
        if (page.getBgColor() != null) {
            Color bgColor = Color.decode(page.getBgColor());
            g2d.setColor(bgColor);
            g2d.fillRect(0, 0, g2d.getClipBounds().width, g2d.getClipBounds().height);
        }
        
        // 按层级排序渲染区域
        List<ProgramRegion> sortedRegions = page.getRegions().stream()
            .sorted(Comparator.comparing(r -> r.getLayer() != null ? r.getLayer() : 0))
            .collect(Collectors.toList());
            
        for (ProgramRegion region : sortedRegions) {
            renderRegion(g2d, region, options);
        }
    }
    
    private void renderRegion(Graphics2D g2d, ProgramRegion region, PreviewOptions options) {
        DisplayRect rect = region.getRect();
        
        // 设置裁剪区域
        Rectangle clipRect = new Rectangle(rect.getX(), rect.getY(), rect.getWidth(), rect.getHeight());
        Graphics2D regionG2d = (Graphics2D) g2d.create();
        regionG2d.setClip(clipRect);
        
        // 渲染区域内的素材项
        for (ProgramItem item : region.getItems()) {
            renderItem(regionG2d, item, rect, options);
        }
        
        // 绘制区域边框（预览模式）
        if (options.isShowBounds()) {
            regionG2d.setColor(Color.RED);
            regionG2d.setStroke(new BasicStroke(1, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 10, new float[]{5}, 0));
            regionG2d.drawRect(rect.getX(), rect.getY(), rect.getWidth(), rect.getHeight());
        }
        
        regionG2d.dispose();
    }
    
    private void renderItem(Graphics2D g2d, ProgramItem item, DisplayRect regionRect, PreviewOptions options) {
        MaterialReference materialRef = item.getMaterialRef();
        if (materialRef == null) return;
        
        switch (item.getItemType()) {
            case "2": // 图片
                renderImageItem(g2d, item, regionRect, options);
                break;
            case "3": // 视频
                renderVideoItem(g2d, item, regionRect, options);
                break;
            case "4", "5": // 文本
                renderTextItem(g2d, item, regionRect, options);
                break;
            case "9": // 时钟
                renderClockItem(g2d, item, regionRect, options);
                break;
            // ... 其他类型
        }
    }
}
```

## 2. 数据存储架构

### 2.1 MySQL 表结构设计
```sql
-- 节目基础信息表 (扩展现有program表)
CREATE TABLE `material_program` (
  `program_id` bigint NOT NULL AUTO_INCREMENT,
  `program_name` varchar(255) NOT NULL COMMENT '节目名称',
  `description` text COMMENT '节目描述',
  
  -- 节目规格
  `canvas_width` int NOT NULL DEFAULT 1920 COMMENT '画布宽度',
  `canvas_height` int NOT NULL DEFAULT 1080 COMMENT '画布高度', 
  `device_type` varchar(50) COMMENT '设备类型',
  
  -- 组织和权限
  `organization_id` bigint NOT NULL COMMENT '组织ID',
  `user_group_id` bigint COMMENT '用户组ID',
  `creator_id` bigint NOT NULL COMMENT '创建者ID',
  `updater_id` bigint COMMENT '更新者ID',
  
  -- 状态管理
  `status` enum('DRAFT','PUBLISHED','ARCHIVED','TEMPLATE') NOT NULL DEFAULT 'DRAFT',
  `approval_status` enum('PENDING','APPROVED','REJECTED') DEFAULT 'PENDING',
  `approver_id` bigint COMMENT '审核者ID',
  `approval_comment` text COMMENT '审核意见',
  
  -- MongoDB文档引用
  `program_content_id` varchar(24) COMMENT 'MongoDB文档ID',
  `vsn_file_id` varchar(255) COMMENT 'VSN文件ID',
  
  -- 版本管理
  `version` int NOT NULL DEFAULT 1,
  `parent_program_id` bigint COMMENT '父节目ID',
  
  -- 使用统计
  `deploy_count` int DEFAULT 0 COMMENT '部署次数',
  `last_deploy_time` datetime COMMENT '最后部署时间',
  
  -- 预览和缩略图
  `thumbnail_path` varchar(500) COMMENT '缩略图路径',
  `preview_video_path` varchar(500) COMMENT '预览视频路径',
  
  -- 分类和标签
  `category` varchar(100) COMMENT '分类',
  `tags` json COMMENT '标签数组',
  
  -- 兼容性
  `supported_device_types` json COMMENT '支持的设备类型',
  `min_player_version` varchar(20) COMMENT '最低播放器版本',
  
  -- 时间戳
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `update_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  
  PRIMARY KEY (`program_id`),
  KEY `idx_org_creator` (`organization_id`, `creator_id`),
  KEY `idx_status` (`status`),
  KEY `idx_content_id` (`program_content_id`),
  CONSTRAINT `fk_program_organization` FOREIGN KEY (`organization_id`) REFERENCES `organization` (`organization_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='节目基础信息表';

-- 节目素材引用关系表
CREATE TABLE `program_material_ref` (
  `ref_id` bigint NOT NULL AUTO_INCREMENT,
  `program_id` bigint NOT NULL COMMENT '节目ID',
  `material_id` bigint NOT NULL COMMENT '素材ID',
  `item_id` varchar(50) NOT NULL COMMENT '节目项ID',
  `ref_type` enum('DIRECT','BACKGROUND','AUDIO') NOT NULL DEFAULT 'DIRECT',
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
  
  PRIMARY KEY (`ref_id`),
  UNIQUE KEY `uk_program_item` (`program_id`, `item_id`),
  KEY `idx_material` (`material_id`),
  CONSTRAINT `fk_pmr_program` FOREIGN KEY (`program_id`) REFERENCES `material_program` (`program_id`) ON DELETE CASCADE,
  CONSTRAINT `fk_pmr_material` FOREIGN KEY (`material_id`) REFERENCES `material` (`mid`) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='节目素材引用关系表';

-- 节目版本历史表
CREATE TABLE `program_version_history` (
  `version_id` bigint NOT NULL AUTO_INCREMENT,
  `program_id` bigint NOT NULL,
  `version` int NOT NULL,
  `program_content_id` varchar(24) NOT NULL COMMENT 'MongoDB快照ID',
  `change_summary` text COMMENT '变更摘要',
  `creator_id` bigint NOT NULL,
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
  
  PRIMARY KEY (`version_id`),
  UNIQUE KEY `uk_program_version` (`program_id`, `version`),
  CONSTRAINT `fk_pvh_program` FOREIGN KEY (`program_id`) REFERENCES `material_program` (`program_id`) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='节目版本历史表';
```

### 2.2 MongoDB 集合设计
```javascript
// program_content 集合结构
{
  "_id": ObjectId("..."),
  "programId": "123",
  "information": {
    "width": 1920,
    "height": 1080,
    "backgroundColor": "#000000",
    "deviceProfile": "LED_INDOOR_P4"
  },
  "pages": [
    {
      "id": "page_1",
      "name": "页面1", 
      "duration": 10000,
      "loopType": 0,
      "bgColor": "#000000",
      "bgFile": {
        "isRelative": "1",
        "filePath": "bg/background.jpg",
        "md5": "d41d8cd98f00b204e9800998ecf8427e"
      },
      "regions": [
        {
          "id": "region_1",
          "name": "主显示区",
          "rect": {
            "x": 0,
            "y": 0,
            "width": 1920,
            "height": 1080,
            "borderWidth": 0,
            "borderColor": "#000000"
          },
          "items": [
            {
              "id": "item_1",
              "itemType": "2", // 图片
              "materialRef": {
                "materialId": "456",
                "fileId": "file_abc123",
                "materialType": "IMAGE",
                "md5Hash": "abc123...",
                "storagePath": "/uploads/2024/01/image.jpg",
                "accessUrl": "http://cdn.example.com/image.jpg"
              },
              "properties": {
                "alpha": "1.0",
                "reserveAS": "0",
                "duration": "5000",
                "inEffect": {
                  "type": "2",
                  "time": "1000"
                }
              }
            }
          ],
          "layer": 1,
          "isScheduleRegion": false
        }
      ]
    }
  ],
  "materialReferences": [
    {
      "materialId": "456",
      "fileId": "file_abc123",
      "materialType": "IMAGE",
      "usageCount": 1,
      "firstUsedAt": ISODate("2024-01-15T10:30:00Z")
    }
  ],
  "editorState": {
    "selectedElements": ["item_1"],
    "viewport": {
      "zoom": 1.0,
      "panX": 0,
      "panY": 0
    },
    "clipboard": []
  },
  "contentVersion": 1,
  "createdAt": ISODate("2024-01-15T10:00:00Z"),
  "updatedAt": ISODate("2024-01-15T10:30:00Z"),
  "editHistory": [
    {
      "action": "ADD_ITEM",
      "itemId": "item_1", 
      "timestamp": ISODate("2024-01-15T10:30:00Z"),
      "userId": "789"
    }
  ]
}

// program_vsn_files 集合 - 存储生成的VSN文件
{
  "_id": ObjectId("..."),
  "programId": "123",
  "version": 1,
  "vsnContent": "<Programs>...</Programs>", // VSN XML内容
  "deploymentMode": "LOCAL",
  "generationOptions": {
    "deviceType": "LED_P4",
    "playerVersion": "1.67.1"
  },
  "materialFiles": [
    {
      "materialId": "456",
      "relativePath": "materials/image_456.jpg",
      "md5": "abc123..."
    }
  ],
  "validationResult": {
    "isValid": true,
    "warnings": [],
    "errors": []
  },
  "generatedAt": ISODate("2024-01-15T11:00:00Z"),
  "generatedBy": "789"
}
```

这个后端架构设计涵盖了：
1. **完整的微服务架构**：清晰的服务职责划分
2. **领域模型扩展**：基于现有系统的自然延伸
3. **VSN生成能力**：完整的XML生成和验证机制
4. **数据存储设计**：MySQL+MongoDB的混合存储策略
5. **版本管理**：完整的版本控制和历史追踪
6. **预览渲染**：基于Graphics2D的预览生成能力