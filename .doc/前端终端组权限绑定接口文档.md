# 终端组权限绑定API使用文档

## 📋 概述

本文档面向前端开发人员，详细说明如何使用终端组权限绑定API，实现用户组与终端组的权限管理功能。

### 核心概念

- **终端组（Terminal Group）**：LED设备的组织结构，支持树形层级管理
- **用户组（User Group）**：用户的分组管理
- **权限绑定**：用户组与终端组之间的访问权限关系
- **INCLUDE/EXCLUDE模式**：支持包含和排除两种权限类型
- **includeChildren**：是否包含子终端组的权限控制

---

## 🏗️ 权限模型

### 权限绑定类型

| 绑定类型 | includeChildren | 说明 | UI展示 |
|---------|----------------|------|--------|
| INCLUDE | true | 包含该终端组及其所有子组 | 🟢 绿色实心 |
| INCLUDE | false | 仅包含该终端组，不包含子组 | 🟢 绿色空心 |
| EXCLUDE | true | 排除该终端组及其所有子组 | 🔴 红色实心 |
| EXCLUDE | false | 仅排除该终端组，不排除子组 | 🔴 红色空心 |

### 权限计算规则

1. **优先级栈模型**：按照终端组的层级深度计算权限
2. **EXCLUDE优先**：EXCLUDE类型的权限优先级高于INCLUDE
3. **智能去重**：系统自动清理冗余的权限配置

---

## 🚀 API接口详解

### 基础URL
```
/terminal-group
```

### 1. 获取终端组树结构

**接口**：`GET /terminal-group/tree/init`

**用途**：获取当前用户可访问的终端组树形结构

**请求示例**：
```javascript
// GET /terminal-group/tree/init
fetch('/terminal-group/tree/init', {
  method: 'GET',
  headers: {
    'Authorization': 'Bearer ' + token
  }
})
```

**响应示例**：
```json
{
  "terminalGroups": [
    {
      "tgid": 1,
      "name": "总部",
      "path": "1",
      "parent": null,
      "children": [
        {
          "tgid": 2,
          "name": "开发部",
          "path": "1|2",
          "parent": 1,
          "children": []
        }
      ]
    }
  ]
}
```

---

### 2. 获取用户组权限状态

**接口**：`GET /terminal-group/permission/status`

**用途**：获取指定用户组的权限绑定状态，用于权限树的初始化展示

**请求参数**：
- `ugid` (Long) - 用户组ID

**请求示例**：
```javascript
// GET /terminal-group/permission/status?ugid=1001
fetch('/terminal-group/permission/status?ugid=1001', {
  method: 'GET',
  headers: {
    'Authorization': 'Bearer ' + token
  }
})
```

**响应示例**：
```json
{
  "ugid": 1001,
  "userGroupName": "开发组",
  "permissionBindings": [
    {
      "bindingId": 1,
      "tgid": 2,
      "terminalGroupName": "开发部",
      "terminalGroupPath": "1|2",
      "bindingType": "INCLUDE",
      "includeChildren": true,
      "depth": 2,
      "parentTgid": 1,
      "createTime": "2024-01-01T10:00:00",
      "remarks": "开发组有权限访问开发部及其子组"
    }
  ],
  "statistics": {
    "totalBindings": 3,
    "includeBindings": 2,
    "excludeBindings": 1,
    "includeChildrenBindings": 2,
    "totalCoveredTerminalGroups": 15,
    "maxDepth": 4
  },
  "lastUpdateTime": "2024-01-01T10:00:00"
}
```

---

### 3. 更新权限表达式

**接口**：`POST /terminal-group/permission/expression/update`

**用途**：全量更新用户组的权限绑定关系

**请求体**：
```json
{
  "ugid": 1001,
  "permissionBindings": [
    {
      "tgid": 1,
      "bindingType": "INCLUDE",
      "includeChildren": true,
      "remarks": "总部权限"
    },
    {
      "tgid": 3,
      "bindingType": "EXCLUDE", 
      "includeChildren": false,
      "remarks": "排除财务部"
    }
  ],
  "description": "更新开发组权限",
  "enableRedundancyOptimization": true
}
```

**请求示例**：
```javascript
const updatePermissions = async (ugid, bindings) => {
  const response = await fetch('/terminal-group/permission/expression/update', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': 'Bearer ' + token
    },
    body: JSON.stringify({
      ugid: ugid,
      permissionBindings: bindings,
      description: '权限更新',
      enableRedundancyOptimization: true
    })
  });
  
  return response.json();
};
```

**响应示例**：
```json
{
  "success": true,
  "processedBindings": 2,
  "optimizedBindings": 1,
  "removedRedundantBindings": 1,
  "finalBindings": [
    {
      "tgid": 1,
      "bindingType": "INCLUDE",
      "includeChildren": true
    }
  ],
  "optimizationSummary": {
    "redundancyDetected": true,
    "conflictResolved": false,
    "optimizationDetails": "移除了1个冗余的子组绑定"
  }
}
```

---

## 🎨 前端交互设计

### 权限树组件设计

#### 1. 树形结构展示
```html
<div class="permission-tree">
  <div class="tree-node" v-for="node in terminalGroups" :key="node.tgid">
    <div class="node-content">
      <!-- 权限状态指示器 -->
      <span class="permission-indicator" 
            :class="getPermissionClass(node.tgid)">
      </span>
      
      <!-- 终端组名称 -->
      <span class="node-name">{{ node.name }}</span>
      
      <!-- 权限控制按钮 -->
      <div class="permission-controls">
        <button @click="setPermission(node.tgid, 'INCLUDE', true)"
                class="btn-include-all" title="包含子组">
          🟢
        </button>
        <button @click="setPermission(node.tgid, 'INCLUDE', false)"
                class="btn-include-only" title="仅包含本组">
          ⚪
        </button>
        <button @click="setPermission(node.tgid, 'EXCLUDE', true)"
                class="btn-exclude-all" title="排除子组">
          🔴
        </button>
        <button @click="setPermission(node.tgid, 'EXCLUDE', false)"
                class="btn-exclude-only" title="仅排除本组">
          ⭕
        </button>
        <button @click="removePermission(node.tgid)"
                class="btn-remove" title="移除权限">
          ❌
        </button>
      </div>
    </div>
    
    <!-- 子节点 -->
    <div class="child-nodes" v-if="node.children">
      <!-- 递归渲染子节点 -->
    </div>
  </div>
</div>
```

#### 2. CSS样式定义
```css
.permission-indicator {
  width: 12px;
  height: 12px;
  border-radius: 50%;
  display: inline-block;
  margin-right: 8px;
}

.permission-indicator.include-all {
  background-color: #52c41a; /* 绿色实心 */
}

.permission-indicator.include-only {
  background-color: transparent;
  border: 2px solid #52c41a; /* 绿色空心 */
}

.permission-indicator.exclude-all {
  background-color: #ff4d4f; /* 红色实心 */
}

.permission-indicator.exclude-only {
  background-color: transparent;
  border: 2px solid #ff4d4f; /* 红色空心 */
}

.permission-indicator.no-permission {
  background-color: #d9d9d9; /* 灰色 */
}
```

#### 3. Vue.js交互逻辑
```javascript
export default {
  data() {
    return {
      terminalGroups: [],
      permissionBindings: [],
      currentUgid: null
    };
  },
  
  methods: {
    // 获取权限状态样式类
    getPermissionClass(tgid) {
      const binding = this.permissionBindings.find(b => b.tgid === tgid);
      if (!binding) return 'no-permission';
      
      if (binding.bindingType === 'INCLUDE') {
        return binding.includeChildren ? 'include-all' : 'include-only';
      } else {
        return binding.includeChildren ? 'exclude-all' : 'exclude-only';
      }
    },
    
    // 设置权限
    setPermission(tgid, bindingType, includeChildren) {
      const existingIndex = this.permissionBindings.findIndex(b => b.tgid === tgid);
      const newBinding = {
        tgid,
        bindingType,
        includeChildren,
        remarks: `${bindingType === 'INCLUDE' ? '包含' : '排除'}${includeChildren ? '(含子组)' : '(仅本组)'}`
      };
      
      if (existingIndex >= 0) {
        this.permissionBindings[existingIndex] = newBinding;
      } else {
        this.permissionBindings.push(newBinding);
      }
      
      // 实时保存
      this.savePermissions();
    },
    
    // 移除权限
    removePermission(tgid) {
      const index = this.permissionBindings.findIndex(b => b.tgid === tgid);
      if (index >= 0) {
        this.permissionBindings.splice(index, 1);
        this.savePermissions();
      }
    },
    
    // 保存权限设置
    async savePermissions() {
      try {
        const response = await fetch('/terminal-group/permission/expression/update', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': 'Bearer ' + this.$store.state.token
          },
          body: JSON.stringify({
            ugid: this.currentUgid,
            permissionBindings: this.permissionBindings,
            description: '权限更新',
            enableRedundancyOptimization: true
          })
        });
        
        const result = await response.json();
        if (result.success) {
          this.$message.success('权限更新成功');
          // 更新本地权限状态
          this.permissionBindings = result.finalBindings;
        }
      } catch (error) {
        this.$message.error('权限更新失败');
      }
    },
    
    // 加载终端组树
    async loadTerminalGroups() {
      try {
        const response = await fetch('/terminal-group/tree/init');
        const data = await response.json();
        this.terminalGroups = data.terminalGroups;
      } catch (error) {
        this.$message.error('加载终端组失败');
      }
    },
    
    // 加载用户组权限状态
    async loadUserGroupPermissions(ugid) {
      try {
        const response = await fetch(`/terminal-group/permission/status?ugid=${ugid}`);
        const data = await response.json();
        this.permissionBindings = data.permissionBindings;
        this.currentUgid = ugid;
      } catch (error) {
        this.$message.error('加载权限状态失败');
      }
    }
  },
  
  mounted() {
    this.loadTerminalGroups();
  }
};
```

---

## 📱 使用场景

### 场景1：新建用户组权限配置
1. 选择用户组
2. 调用 `loadUserGroupPermissions()` 获取当前权限状态
3. 在权限树上进行权限配置
4. 系统自动调用 `updatePermissionExpression` 保存

### 场景2：修改现有权限
1. 加载现有权限配置
2. 在树形界面上修改权限设置
3. 实时保存并显示优化结果

### 场景3：权限继承展示
1. 展示父子关系的权限继承
2. 智能提示权限冲突
3. 自动优化冗余配置

---

## ⚠️ 重要注意事项

### 1. 权限计算逻辑
- **EXCLUDE优先**：当同一终端组既有INCLUDE又有EXCLUDE时，EXCLUDE生效
- **子组继承**：`includeChildren=true`时，子组自动继承权限
- **智能优化**：系统自动清理冗余的权限配置

### 2. 前端交互原则
- **实时反馈**：权限变更立即生效并提供视觉反馈
- **智能提示**：当配置可能产生冲突时提供警告
- **批量操作**：支持批量设置多个终端组权限

### 3. 性能优化建议
- **懒加载**：大型终端组树使用懒加载
- **防抖保存**：用户连续操作时使用防抖机制
- **状态缓存**：合理缓存权限状态减少API调用

### 4. 错误处理
- **网络异常**：提供重试机制
- **权限不足**：友好的错误提示
- **数据校验**：前端预校验减少后端请求

---

## 🔧 调试工具

### 权限状态检查器
```javascript
// 调试用：检查当前权限配置
const debugPermissions = (ugid) => {
  console.log('=== 权限配置调试 ===');
  console.log('用户组ID:', ugid);
  console.log('权限绑定:', this.permissionBindings);
  console.log('计算结果:', this.calculateEffectivePermissions());
};
```

### 权限模拟器
```javascript
// 模拟权限计算结果
const simulatePermission = (tgid) => {
  // 实现权限计算逻辑的前端模拟
  // 用于在保存前预览权限效果
};
```

---

## 📞 技术支持

如有问题请联系：
- **后端API支持**：core-service团队
- **前端组件支持**：UI/UX团队
- **权限模型咨询**：架构组

---

*最后更新：2024年7月19日*